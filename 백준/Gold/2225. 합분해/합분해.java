

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		// 정수 N을 입력 받자.
		int N = sc.nextInt();

		// 선택할 수 K를 입력 받자.
		int K = sc.nextInt();

		// (N,K)를 구하기 위해 배열의 크기를 N+1, K+1로 만든다.
		// arr의 첫번째 배열은 N개의 수 이다.
		// arr의 두번째 배열은 조합해야 하는 수 K이다.
		// 즉, arr[N][K]는, N번째 수를, K개를 더해 만들 수 있는 경우의 수가 저장된다.
		int[][] arr= new int[N+1][K+1];
		
		// 숫자 1개를 가지고 만드는 최소수는 자기 자신이므로,
		// arr[1][i]은 예를 들어 i가 1이라면, 1이라는 숫자를 1개의 숫자로
		// 만들 수 있는 경우의 수는, 자기자신밖에 없으므로, 1을 저장한다.
		// 0은 
		for(int i=0; i<=N; i++) {
			arr[i][1]=1;
		}
		for(int i=2; i<=K; i++) {
			arr[0][i]=1;
		
		}
		// DP를 이용해 해결해보자.
		// arr배열을 그려보자.
		// ↓ : K개의 수  → : N     => K개의 수로 N을 만드는 경우의 수
		/*    0  1  2  3  4  5
		 * 0  1  0  0  0  0  0  => 0개의 수로 0,1,2,3,4,5를 만들 수 있는 경우의 수는 없음
		 * 1  1  1  1  1  1  1  => 1개의 수로 0,1,2,3,4,5를 만드는 경우의 수는 자기 자신 뿐, 0은 항상 자기 자신만 가능하다.
		 * 2  1  2  3  4  5  6  => 2개의 수로 1을 만드는 경우의 수는, (0,1) (0,2) 2는 (0,2) (2,0) (1,1) 
		 * 3  1  3  6 10 15 21
		 * 4  1  4 10 20 35 56
		 * 5  1  5 15 35 70 126
		 * => 얻을 수 있는 규칙은, 구하고자 하는 배열은 위와 왼쪽을 더하면 된다.
		 * => 이를 식으로 표현하면 arr[N][K] = arr[N-1][K] + arr[N][K-1]이 된다.  
		 */
		// 0번째는 배열을 만들 때 0으로 초기화가 되어있고,
		// 1번째는 위 식에서 1로 초기화 시켰으므로, k는 2부터 검사하자.
		// 지금까지 만들어진 식은

		for(int k=2; k<=K; k++) {
			// N은 1부터 검사한다.
			for(int n=1; n<=N; n++) {
				arr[n][k]=(arr[n-1][k]+arr[n][k-1]) % 1000000000;
			}
		}
		System.out.println(arr[N][K]);
		
	}
}
